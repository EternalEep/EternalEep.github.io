<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode74-Search a 2D Matrix]]></title>
    <url>%2F2018%2F10%2F27%2FLeetcode74%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode1-Two Sum]]></title>
    <url>%2F2018%2F10%2F27%2FLeetcode1%2F</url>
    <content type="text"><![CDATA[Solution 1 Approach Brute Force Loop through each element and find x if there is another value that equals to target-x Complexity Analysis Time complexity: O(n^2) Space complexity: O(1) Runtime: 172ms12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; index; for(int i=0;i&lt;nums.size()-1;i++)&#123; for(int j=i+1;j&lt;nums.size();j++)&#123; if(nums[j]==target-nums[i])&#123; index.push_back(i); index.push_back(j); return index; &#125; &#125; &#125; throw "No two sum solution"; &#125;&#125;; Runtime:92ms 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; index; int result; vector&lt;int&gt;::iterator it; for(int i=0;i&lt;nums.size()-1;i++)&#123; result = target-nums[i]; it = find(nums.begin()+i+1,nums.end(),result); if(it!=nums.end())&#123; index.push_back(i); index.push_back(distance(nums.begin(),it)); return index; &#125; &#125; throw "No two sum solution"; &#125;&#125;; Solution 2 Approach One-pass Hash Table While we iterate and inserting elements into the table, we also look back to check if current element’s complement already exsits in the table. If it exists, we have found a solution and return immediately. Complexity Analysis Time complexity: O(n) Space complexity: O(1) Runtime: 8ms12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; sum; unordered_map&lt;int,int&gt;::iterator it; vector&lt;int&gt; index; for(int i=0;i&lt;nums.size();i++)&#123; it = sum.find(target-nums[i]); if(it!=sum.end())&#123; return vector&lt;int&gt;&#123;it-&gt;second,i&#125;; &#125; else&#123; sum.insert(&#123;nums[i],i&#125;); &#125; &#125; throw "no two sum"; &#125;&#125;; 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; sum; for(int i=0;i&lt;nums.size();i++) &#123; if(sum.count(target-nums[i]))&#123; return vector&lt;int&gt;&#123;i,sum[target-nums[i]]&#125;; &#125; else&#123; sum[nums[i]]=i; &#125; &#125; throw "no two sum"; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode70-Climbing Stairs]]></title>
    <url>%2F2018%2F10%2F19%2FLeetcode70%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode20-Valid Parentheses]]></title>
    <url>%2F2018%2F10%2F18%2FLeetcode20%2F</url>
    <content type="text"><![CDATA[Solution 1 Approach Initialize stack S. Process each bracket of the expression one at a time. If we encounter an opening bracket, we simply push it onto the stack. This means we will process it later, let us simply move onto the sub-expression ahead. If we encouter a closing bracket, then we check the element on top of the stack. If the element at the top of the stack is an opening bracket of the same type, then we pop it off the stack and continue processing. Else, this implies an invalid expression. In the end, if we are left with a stack still having elements, then this implies an invalid expression. Tips char of c++ using ‘ ‘ not “ “ We should judge if the stack is empty? It is important. If we search the closing bracket, stack is empty, it is invalid. If we search the open bracket, stack is empty, then push onto the stack for next search iteration. Complexity Analysis Time complexity:O(n) Space complexity:O(n) Runtime:4ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; st; // len=0 return true if(s.length()==0)&#123; return true; &#125; // right char if(s[0]==')'||s[0]==']'||s[0]=='&#125;')&#123; return false; &#125; st.push(s[0]); for(int i=1;i&lt;s.length();i++)&#123; if(s[i]==')')&#123; if(!st.empty() &amp;&amp; st.top()=='(')&#123; st.pop(); &#125; else&#123; return false; &#125; &#125; else if(s[i]==']')&#123; if(!st.empty() &amp;&amp; st.top()=='[')&#123; st.pop(); &#125; else&#123; return false; &#125; &#125; else if(s[i]=='&#125;')&#123; if(!st.empty() &amp;&amp; st.top()=='&#123;')&#123; st.pop(); &#125; else&#123; return false; &#125; &#125; else&#123; st.push(s[i]); &#125; &#125; if(st.empty())&#123; return true; &#125; return false; &#125;&#125;; Solution 2 Approach Using unordered_map stl structure unordered_map hash can match the brackets and save code lines others are the same as Solution 1 Complexity Analysis Time complexity: O(n) Space complexity: O(n) Runtime: 0ms1234567891011121314151617181920212223class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; st; unordered_map&lt;char,char&gt; hash&#123;&#123;'(',')'&#125;,&#123;'&#123;','&#125;'&#125;,&#123;'[',']'&#125;&#125;; for(int i=0; i&lt;s.length(); i++)&#123; if(s[i]=='['||s[i]=='&#123;'||s[i]=='(')&#123; st.push(s[i]); &#125; else if(!st.empty() &amp;&amp; hash[st.top()]==s[i])&#123; st.pop(); &#125; else&#123; return false; &#125; &#125; if(st.empty())&#123; return true; &#125; else&#123; return false; &#125; &#125;&#125;;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode53-Maximum Subarray]]></title>
    <url>%2F2018%2F10%2F17%2FLeetcode53%2F</url>
    <content type="text"><![CDATA[Solution Approach 1 Progressive summation Continuously find the sum of the subsequences starting with nums[i] Recording the sum of the largest subsequences in the process of seeking Complexity Analysis Time complexity:O($$n^2$$) Space complexity:O(1) Runtime: 160ms12345678910111213141516class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxSum = nums[0]; for(int i=0;i&lt;nums.size();i++)&#123; int sum = 0; for(int j=i;j&lt;nums.size();j++)&#123; sum+=nums[j]; if(sum&gt;maxSum)&#123; maxSum = sum; &#125; &#125; &#125; return maxSum; &#125;&#125;; Approach 2 Juddging summation A num adding a negative num will be reduced Adding from nums[0], if sum&gt;maxSum, then substitute maxSum if sum&lt;0, then throwing away current sum, move to next nums, calculating sum again Complexity Analysis Time complexity:O(n) Space complexity:O(1) Runtime: 8ms1234567891011121314151617class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; int maxSum = nums[0]; for(int i=0;i&lt;nums.size();i++)&#123; sum+=nums[i]; if(sum&gt;maxSum)&#123; maxSum=sum; &#125; if(sum&lt;0)&#123; sum = 0; &#125; &#125; return maxSum; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode236-Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2018%2F10%2F10%2FLeetcode236%2F</url>
    <content type="text"><![CDATA[Solution Approach The common Ancestor of two nodes is in the path to the two nodes The lowest Common Ancestor is the node far away from the root and appearing in the two path simutaneously So we calculate the pPath and qPath result and find the lasted common node in two path Tips Preorder the p and q path (we should pay attention to that using the pResult and qResult to store result. In recursive funciton, when search the goal, then copy pPath/qPath to result). Need the tag “finish” to mark if the search finished, if finished, then don’t search deeper. Complexity Analysis Time Complexity: O(n) Space Complexity: O(n)123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; vector&lt;TreeNode*&gt; pPath; vector&lt;TreeNode*&gt; qPath; vector&lt;TreeNode*&gt; pResult; vector&lt;TreeNode*&gt; qResult; int finish = 0; treeNodePath(root,p-&gt;val, finish, pPath, pResult); finish = 0; treeNodePath(root,q-&gt;val, finish, qPath, qResult); int pathlen; if(pResult.size()&lt;qResult.size())&#123; pathlen = pResult.size(); &#125; else&#123; pathlen = qResult.size(); &#125; int index; for(int i=0;i&lt;pathlen;i++)&#123; if(pResult[i]==qResult[i])&#123; index = i; &#125; &#125; return pResult[index]; &#125;private: void treeNodePath(TreeNode* node, int val, int finish, vector&lt;TreeNode*&gt;&amp; path, vector&lt;TreeNode*&gt;&amp; result)&#123; if(!node || finish)&#123; return; &#125; path.push_back(node); if(node-&gt;val==val)&#123; finish=1; result= path; &#125; treeNodePath(node-&gt;left,val,finish, path, result); treeNodePath(node-&gt;right,val,finish, path, result); path.pop_back(); &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode113 - Path Sum II]]></title>
    <url>%2F2018%2F10%2F09%2FLeetcode113%2F</url>
    <content type="text"><![CDATA[Solution Approach Deep traverse the binary tree from root, when preorder, push_back node value into path vector and use path_value add node value When travese to “leaf node”(need leaf node judgement!!)”, check if path_value==sum, then push path into result when postorder, pop_back the current node value, and path_value sub node value Complexity Analysis Time Complexity: O(n) Space Complexity: O(n)12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum)&#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int path_val = 0; preorder_pathSum(root,sum,path_val,path,result); return result; &#125;private: void preorder_pathSum(TreeNode*node, int sum, int &amp;path_val, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;result)&#123; if(!node) &#123; return; &#125; path.push_back(node-&gt;val); path_val+=node-&gt;val; if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; path_val==sum) &#123; result.push_back(path); &#125; preorder_pathSum(node-&gt;left,sum,path_val,path,result); preorder_pathSum(node-&gt;right,sum,path_val,path,result); path_val-=node-&gt;val; path.pop_back(); &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[heap]]></title>
    <url>%2F2018%2F10%2F09%2Fheap%2F</url>
    <content type="text"><![CDATA[Small heap and Big heap using STL default priority_queue is big_heap1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int main()&#123; // small_heap/big_heap realization priority_queue&lt;int&gt; big_heap; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; small_heap; priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; big_heap2; if (big_heap.empty())&#123; printf("big_heap is empty!\n"); &#125; int test[] = &#123;6, 10, 1, 7, 99, 4, 33&#125;; for (int i = 0; i &lt; 7; i++)&#123; big_heap.push(test[i]); &#125; printf("big_heap.top = %d\n", big_heap.top()); big_heap.push(1000); printf("big_heap.top = %d\n", big_heap.top()); for (int i = 0; i &lt; 3; i++)&#123; big_heap.pop(); &#125; printf("big_heap.top = %d\n", big_heap.top()); printf("big_heap.size = %d\n", big_heap.size()); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[BinaryTree]]></title>
    <url>%2F2018%2F10%2F07%2FBinaryTree%2F</url>
    <content type="text"><![CDATA[Data Structure for BinaryTree- BinaryTree Initialization - PreOrder - InOrder - PostOrder - BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;//preordervoid preorder_print(TreeNode *node, int layer)&#123; if(!node)&#123; return; &#125; for(int i=0; i&lt;layer; i++)&#123; printf("--------"); // print amount of "-" according to the layer &#125; printf("[%d]\n", node-&gt;val); preorder_print(node-&gt;left, layer+1); //traverse left subtree, layer+1 preorder_print(node-&gt;right, layer+1);//traverse right subtree, layer+1&#125;//inordervoid inorder_print(TreeNode *node, int layer)&#123; if(!node)&#123; return; &#125; inorder_print(node-&gt;left,layer+1); for(int i=0; i&lt;layer; i++)&#123; printf("--------"); // print amount of "-" according to the layer &#125; printf("[%d]\n", node-&gt;val); inorder_print(node-&gt;right,layer+1);&#125;//postordervoid postorder_print(TreeNode *node, int layer)&#123; if(!node)&#123; return; &#125; postorder_print(node-&gt;left,layer+1); postorder_print(node-&gt;right,layer+1); for(int i=0; i&lt;layer; i++)&#123; printf("--------"); // print amount of "-" according to the layer &#125; printf("[%d]\n", node-&gt;val);&#125;void traversal(TreeNode *node)&#123; if(!node)&#123; return; &#125; //preorder traversal(node-&gt;left); //inorder traversal(node-&gt;right); //postorder&#125;// BFS_searchvoid BFS_print (TreeNode* root)&#123; queue&lt;TreeNode*&gt; Q; Q.push(root); while(Q.front())&#123; TreeNode *node = Q.front(); Q.pop(); printf("[%d]\n", node-&gt;val); if(node-&gt;left)&#123; Q.push(node-&gt;left); &#125; if(node-&gt;right)&#123; Q.push(node-&gt;right); &#125; &#125;&#125;int main() &#123; TreeNode a(1); TreeNode b(2); TreeNode c(5); TreeNode d(3); TreeNode e(4); TreeNode f(6); a.left = &amp;b; a.right = &amp;c; b.left = &amp;d; b.right = &amp;e; c.right = &amp;f; preorder_print(&amp;a, 0); printf("***************\n"); inorder_print(&amp;a, 0); printf("***************\n"); postorder_print(&amp;a, 0); printf("***************\n"); BFS_print(&amp;a); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode215-Kth Largest Element in an Array]]></title>
    <url>%2F2018%2F10%2F06%2FLeetcode215%2F</url>
    <content type="text"><![CDATA[Solution- Approach - Maintain a k size min-heap - Guarantee numbers of element equal to k - if numbers of elements is less than k, push it to heap, else if element is larger than heap top, pop heap top and add new element - finally, the top element is the k-th largest number - Complexity Analysis - Time Complexity: O(Nlogk) - Space Complexity: O(k) - Runtime: 4ms 12345678910111213141516171819class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; small_heap; for(int i=0;i&lt;nums.size();i++)&#123; if(i&lt;k)&#123; small_heap.push(nums[i]); &#125; else&#123; if(nums[i]&gt;small_heap.top())&#123; small_heap.pop(); small_heap.push(nums[i]); &#125; &#125; &#125; return small_heap.top(); &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode155 - Min Stack]]></title>
    <url>%2F2018%2F10%2F04%2FLeetcode155%2F</url>
    <content type="text"><![CDATA[Solution Approach using another stack to store the minimum every state getMin() return the min stack top Complexity Analysis Time complexity: push O(1) Space complexity: push O(n)1234567891011121314151617181920212223242526272829303132333435363738394041class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; _data.push(x); if(_min.empty())&#123; _min.push(x); &#125; else&#123; int t = _min.top(); if(t&gt;x)&#123; _min.push(x); &#125; else&#123; _min.push(t); &#125; &#125; &#125; void pop() &#123; _data.pop(); _min.pop(); &#125; int top() &#123; return _data.top(); &#125; int getMin() &#123; return _min.top(); &#125;private: stack&lt;int&gt; _data; stack&lt;int&gt; _min;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode232-Implement Queue using Stacks]]></title>
    <url>%2F2018%2F10%2F03%2FLeetcode232%2F</url>
    <content type="text"><![CDATA[Solution Approach when queue push, using temp_stack to swap element order push exisited data_stack to temp_stack add new element to temp_stack copy temp_stack to data_stack then data_stack is the final queue result Complexity Analysis Time complexity: push O(n), other O(1) Space complexity: O(1)1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyQueue &#123;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; stack&lt;int&gt; temp_stack; while(!_data.empty())&#123; temp_stack.push(_data.top()); _data.pop(); &#125; temp_stack.push(x); while(!temp_stack.empty())&#123; _data.push(temp_stack.top()); temp_stack.pop(); &#125; &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; int x = _data.top(); _data.pop(); return x; &#125; /** Get the front element. */ int peek() &#123; return _data.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return _data.empty(); &#125;private: stack&lt;int&gt; _data;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode225 - Implement Stack using Queues]]></title>
    <url>%2F2018%2F10%2F03%2FLeetcode225%2F</url>
    <content type="text"><![CDATA[Solution Approach when Stack push, using temp_queue to swap element order add new element to temp_queue push exisited data_queue to temp_queue copy temp_queue to data_queue then data_queue is the final stack result Complexity Analysis Time complexity: push O(n), other O(1) Space complexity: O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; std::queue&lt;int&gt; temp_queue; temp_queue.push(x); while(!_data.empty())&#123; temp_queue.push(_data.front()); _data.pop(); &#125; while(!temp_queue.empty())&#123; _data.push(temp_queue.front()); temp_queue.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int x = _data.front(); _data.pop(); return x; &#125; /** Get the top element. */ int top() &#123; return _data.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return _data.empty(); &#125;private: //data stores the elements order is the order of stack std::queue&lt;int&gt; _data;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * bool param_4 = obj.empty(); */]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode387 - First Unique Character in a String]]></title>
    <url>%2F2018%2F09%2F25%2FLeetcode387%2F</url>
    <content type="text"><![CDATA[Solution Approach 1 using (cnt[p-‘a’]) to record the alphabet count (cnt[s[i]-‘a’]==1) then return i with s.size(), not cnt.size() Complexity Analysis Time complexity: O(n) Space complexity: O(1)123456789101112131415class Solution &#123;public: int firstUniqChar(string s) &#123; vector&lt;int&gt; cnt(26,0); for(char p:s)&#123; cnt[p-'a']+=1; &#125; for(int i=0;i&lt;s.size();i++)&#123; if(cnt[s[i]-'a']==1)&#123; return i; &#125; &#125; return -1; &#125;&#125;; Approach 2 traverse the s Complexity Analysis Time complexity: O(n^2) Space complexity: O(1)12345678910111213141516171819class Solution &#123;public: int firstUniqChar(string s) &#123; int b = 0; for(int i=0;i&lt;s.size();i++)&#123; for(int j=0;j&lt;s.size();j++)&#123; b = 0; if(i!=j) &#123; if (s[j]==s[i]) &#123; b++; break; &#125; &#125; &#125; if(!b) return i; &#125; return -1; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode541-Reverse String II]]></title>
    <url>%2F2018%2F09%2F24%2FLeetcode541%2F</url>
    <content type="text"><![CDATA[Solution Approach using swap function to swap element notice that if end &gt; size-1 then modify end.1234567891011121314151617class Solution &#123;public: string reverseStr(string s, int k) &#123; for (int i = 0; i &lt; s.size(); i += 2 * k) &#123; int begin = i; int end = i + k - 1; if (end &gt; s.size()-1)&#123; end = s.size() - 1; &#125; while (begin &lt; end) &#123; swap(s[end--], s[begin++]); &#125; &#125; return s; &#125;&#125;; Approach using reverse function min should include iterator, not int value can not use s.size()-1, if len(string)=4 and k=4, it will have error.123456789class Solution &#123;public: string reverseStr(string s, int k) &#123; for (int i = 0; i &lt; s.size(); i += 2 * k) &#123; reverse(s.begin()+i,min(s.begin()+i+k, s.end())); &#125; return s; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode344-Reverse String]]></title>
    <url>%2F2018%2F09%2F24%2FLeetcode344%2F</url>
    <content type="text"><![CDATA[Solution Approach reverse traversing begin and end using “reverse” function We don’t need to consider the null string. Complexity Analysis Time complexity: O(n) Space complexity: O(1) Runtime: 8ms 12345678910111213141516171819class Solution &#123;public: string reverseString(string s) &#123; // if (s=="") &#123; // return s; // &#125; int len = s.size(); int tmp; int i = 0; int j = len-1; while(i&lt;j)&#123; swap(s[i++],s[j--]); // tmp = s[j]; // s[j--] = s[i]; // s[i++] = tmp; &#125; return s; &#125;&#125;; 1234567class Solution &#123;public: string reverseString(string s) &#123; reverse(s.begin(), s.end()); return s; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode21 - Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F09%2F22%2FLeetcode21%2F</url>
    <content type="text"><![CDATA[Solution Approach Set temperal head node pre, and save pre l1/l2 is null, then return l2/l1, this is the trick to be considered when l1&amp;l2 is not null, compare l1 value and l2 value connect pre with l1/l2 whose value is smaller move the smaller l to next move pre to next node when some l is null, we should judge if any of l1/l2 is not null, then connect pre with it(important) another import tips is that the second judge statement, l1!=nullptr should be added into it. - If the first judge have moved the l1 to nullptr, then l1-&gt;val can not be got. - There are &quot;member access within null pointer of type &apos;struct ListNode&apos;&quot; error final return pre_save-&gt;next1if(l1!=nullptr &amp;&amp; l1-&gt;val&gt;l2-&gt;val) Complexity Analysis Time complexity: O(n) Space complexity: O(1) Runtime: 8ms 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; // set temporary listnode head ListNode t_node(0); ListNode *pre = &amp;t_node; ListNode *pre_save = pre; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; while(l1!=nullptr &amp;&amp; l2!=nullptr)&#123; if(l1-&gt;val&lt;=l2-&gt;val) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; pre = pre-&gt;next; &#125; if(l1!=nullptr &amp;&amp; l1-&gt;val&gt;l2-&gt;val)&#123; pre-&gt;next = l2; l2 = l2-&gt;next; pre = pre-&gt;next; &#125; if(l1 != nullptr)&#123; pre-&gt;next = l1; &#125; if(l2 != nullptr)&#123; pre-&gt;next = l2; &#125; &#125; return pre_save-&gt;next; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode92-Reverse Linked List II]]></title>
    <url>%2F2018%2F09%2F19%2FLeetcode92%2F</url>
    <content type="text"><![CDATA[Solution 1 Find keynotes reverse phase pervious head: pre_head head node before reverse -&gt; tail node after reverse: modify_list_tail tail node before reverse -&gt; head node after reverse: new_head reverse phase tail node next note Steps find the node to begin reversing head move m-1 times to find modify_list_tail reverse n-m+1 node connect pre_head and new_head connect modify_list_tail and head Tips not to change m cnt&lt;(n-m+1) to ensure that the head is the reverse phase’s next node discuss the pre_head, if it is none, the reverse begin with index 1, so the p is the result head Complexity Analysis Time Complexity: O(n) Space Complexity: O(1) Runtime: 0ms1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; ListNode *pre_head = nullptr; ListNode *result = head; int cnt_m = 0; // find pre_head while (head &amp;&amp; cnt_m&lt;m-1) &#123; pre_head = head; head = head-&gt;next; cnt_m++; &#125; ListNode *modify_list_tail = head; int cnt = 0; ListNode *p = nullptr; ListNode *next = nullptr; while (cnt &lt; (n-m+1) ) &#123; next = head-&gt;next; head-&gt;next = p; p = head; head = next; cnt++; &#125; modify_list_tail-&gt;next = head; if(pre_head)&#123; pre_head-&gt;next = p; return result; &#125; else&#123; return p; &#125; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Time complexity analysis]]></title>
    <url>%2F2018%2F09%2F07%2FTimecomplexity%2F</url>
    <content type="text"><![CDATA[This is time complexity analysis tutorials some resources Understanding Time complexity with Simple Examples Link How to analyse time complexity: Count your steps Link Time Complexity of Algorithms Link Big O notation: definition and examples Link Time complexity of recursive functions Link Time Complexity Count Tips Purpose: reason about execution time in a way that depends only on the algorithm and input elementary operation cannot be performed more frequently as the size of input grows time to execute an elementary operation must be constant, cannot increase as the size of input grows Definition: time complexity T(n) as the number of such operations the algorithm performs given array of len n Worst-case timeIt gives an upper bound on time requirements and is easy to compute. Average-case time execution times for all possible inputs of size n and prob. of all inputs. hard to compute Linear vs. quadratic time Quadratic time complexity1234567// Reverse the order of the elements in the array a.Algorithm reverse(a): for i = 1 to len(a)-1 x ← a[i] for j = i downto 1 a[j] ← a[j-1] //element operation a[0] ← x ${W_n = 1+2+…+n-1=n(n-1)/2=n^2/2-n/2}$, ${O(n^2)}$ Linear time complexity123Algorithm reverse(a): for i = 0 to n/2 swap a[i] and a[n-i-1] improved algorithm has ${O(n)}$ Big O notation Definition ${T(n)\in{O(f(n))}}$ Constant time complexity ${T(n)\in{O(1}}$ Linear time complexity ${T(n)\in{O(n}}$ Quadratic time complexity ${T(n)\in{O(n^2}}$ Sloppy notation Big Omega is used to give a lower bound for the growth of a function. O(nlogn) is really good， grow very slowly Time complexity of recursive functions Basic examples O(n) Binary search O(logn) Master Therom]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode59-Spiral Matrix II]]></title>
    <url>%2F2018%2F09%2F06%2FLeetcode59%2F</url>
    <content type="text"><![CDATA[Solution Some tips to notify n is zero, return initial matrix two dimensional vector initialize with size vector&lt;vector&gt; spiral (n,vector(n,0)); when matrix spiral, the element is updated by (cnt+1), not (cnt+1)^2 Complexity Analysis Time complexity: O(N) Space complexity:O(N) Runtime: 0ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n)&#123; vector&lt;vector&lt;int&gt;&gt; spiral (n,vector&lt;int&gt;(n,0)); if(n) &#123; int r1 = 0; int c1 = 0; int r2 = n; int c2 = n; int bound = r2*c2; int cnt = 0; while (cnt&lt;bound) &#123; // Only a line if (r1 == (r2 - 1)) &#123; for (int c = c1; c &lt; c2; c++) &#123; spiral[r1][c] = cnt + 1; cnt++; &#125; &#125; else if (c1 == (c2 - 1)) &#123; for (int r = r1; r &lt; r2; r++) &#123; spiral[r][c1] = cnt + 1; cnt++; &#125; &#125; else &#123; // The first line should be printed completely. for (int c = c1; c &lt; c2; c++) &#123; spiral[r1][c] = cnt + 1; cnt++; &#125; for (int r = r1 + 1; r &lt; r2 - 1; r++) &#123; spiral[r][c2 - 1] = cnt + 1; cnt++; &#125; for (int c = c2 - 1; c &gt; c1; c--) &#123; spiral[r2 - 1][c] = cnt + 1; cnt++; &#125; for (int r = r2 - 1; r &gt; r1; r--) &#123; spiral[r][c1] = cnt + 1; cnt++; &#125; r1++; c1++; r2--; c2--; &#125; &#125; &#125; return spiral; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode54-Spiral Matrix]]></title>
    <url>%2F2018%2F09%2F06%2FLeetcode54%2F</url>
    <content type="text"><![CDATA[Solution Some tips to notify matrix.size is zero Using layer-by-layer approach, the k-th layer has minimum distance to boader equak to k for each outer layer, iterate through elements in clockwise pay attention to the specific situation such as only a line/column print top-left coordinates(r1,c1) bottom-right coordinates(r2,c2)| top | c from c1,…,c2-1 ||——–|———————-|| right | r from r1+1,…,r2-2 || bottom | c from c2-1,…,c1+1 || left | r from r2-1,…,r1+1 | Complexity Analysis Time complexity: O(N) Space complexity:O(N) Runtime: 0ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; spiral; if(matrix.size()==0) return spiral; else&#123; int r1 = 0; int c1 = 0; int r2 = matrix.size(); int c2 = matrix[0].size(); int bound = r2*c2; int cnt = 0; while(cnt&lt;bound) &#123; // Only a line with 1*c2 size if (r1 == (r2-1)) &#123; for(int c=c1; c&lt;c2; c++)&#123; spiral.push_back(matrix[r1][c]); cnt++; &#125; &#125; // Only a column with r2*1 size else if(c1 == (c2-1))&#123; for(int r=r1; r&lt;r2; r++)&#123; spiral.push_back(matrix[r][c1]); cnt++; &#125; &#125; // line and column with r2*c2 size else &#123; // The first line should be printed completely. for (int c = c1; c &lt; c2; c++) &#123; spiral.push_back(matrix[r1][c]); cnt++; &#125; for (int r = r1+1; r &lt; r2 - 1; r++) &#123; spiral.push_back(matrix[r][c2 - 1]); cnt++; &#125; for (int c = c2 - 1; c &gt; c1; c--) &#123; spiral.push_back(matrix[r2 - 1][c]); cnt++; &#125; for (int r = r2 - 1; r &gt; r1; r--) &#123; spiral.push_back(matrix[r][c1]); cnt++; &#125; r1++; c1++; r2--; c2--; &#125; &#125; &#125; return spiral; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode350-Intersection of Two Arrays II]]></title>
    <url>%2F2018%2F09%2F06%2FLeetcode350%2F</url>
    <content type="text"><![CDATA[Solution 1 Traverse traverse nums2, find intersection, push_back and then erase notify to len2-1 each finding loop Complexity analysis Time complexity: O(n^2) Space complexity: O(n) Runtime: 8ms123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; intersect; int len2 = nums2.size(); for(int num:nums1)&#123; for(int i=0; i&lt;len2; i++)&#123; if(nums2[i]==num)&#123; intersect.push_back(num); nums2.erase(nums2.begin()+i); len2-=1; break; &#125; &#125; &#125; return intersect; &#125;&#125;; Solution 2 iterator using iterator it to find the num, then push_back and erase num Complexity analysis Time complexity: O(n^2) Space complexity: O(n) Runtime: 4ms12345678910111213141516#include&lt;algorithm&gt;class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; intersect; vector&lt;int&gt;::iterator it; for(int num:nums1)&#123; it = find(nums2.begin(),nums2.end(),num); if(it!=nums2.end())&#123; intersect.push_back(num); nums2.erase(it); &#125; &#125; return intersect; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode349-Intersection of Two Arrays]]></title>
    <url>%2F2018%2F09%2F06%2FLeetcode349%2F</url>
    <content type="text"><![CDATA[Solution 1 Using stl std::set set/unsorted_set detail approach can be seen in my mubu notes for(int num:nums1) can traverse the elements in array set can only use set.insert() to add element set.find(num) can find some element num Complexity analysis Time complexity: O(n^2) Space complexity: O(n) Runtime: 8ms1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; set&lt;int&gt; nums2Set(nums2.begin(),nums2.end()); set&lt;int&gt; intersection; for(int num:nums1)&#123; if(nums2Set.find(num)!=nums2Set.end()) intersection.insert(num); &#125; vector&lt;int&gt; intersect(intersection.begin(),intersection.end()); return intersect; &#125;&#125;; Solution 2 Using unorered_set other is the same as set, but unordered_set is with hashmap Complexity analysis Time complexity: O(n^2) Space complexity: O(n) Runtime: 8ms1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; nums2Set(nums2.begin(),nums2.end()); unordered_set&lt;int&gt; intersection; for(int num:nums1)&#123; if(nums2Set.find(num)!=nums2Set.end()) intersection.insert(num); &#125; vector&lt;int&gt; intersect(intersection.begin(),intersection.end()); return intersect; &#125;&#125;; Solution 3 Using unordered_set for num in set, count num in set2, if it return 1(exist), erase the current num in set2, and push_back in stored vector. Complexity analysis Time complexity: O(n^2) Space complexity: O(n) Runtime: 8ms1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; nums2Set(nums2.begin(),nums2.end()); vector&lt;int&gt; intersection; for(int num:nums1)&#123; if(nums2Set.count(num))&#123; nums2Set.erase(num); intersection.push_back(num); &#125; &#125; return intersection; &#125;&#125;; Solution 4 if the array is ordered, we can use approach below Complexity analysis Time complexity: O(n) Space complexity: O(n) Runtime: 8ms12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; intersection; int i = 0; int j = 0; while(i&lt;nums1.size() &amp;&amp; j&lt;nums2.size())&#123; if(nums1[i]&gt;nums2[j])&#123; j++; &#125; if(nums1[i]==nums2[j])&#123; intersection.push_back(nums1[i]); i++; j++; &#125; if(nums1[i]&lt;nums2[j])&#123; i++; &#125; &#125; return intersection; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode206-Reverse Linked List]]></title>
    <url>%2F2018%2F09%2F06%2FLeetcode206%2F</url>
    <content type="text"><![CDATA[Solution 1 Iterative traverse the list, change the current node’s next pointer to point to previous element. need another pointer to store the next node before changing reference. don’t forget to return the new head reference at the end. Complexity analysis Time complexity: O(n) Space complexity: O(1) Runtime: 4ms123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *p = nullptr; while(head)&#123; ListNode *next = head-&gt;next; head-&gt;next = p; p = head; head = next; &#125; return p; &#125;&#125;; Solution 2 Recursive n1-&gt;…-&gt;n(k-1)-&gt;nk-&gt;n(k+1)&lt;-…&lt;-nm so nk.next.next = nk n1.next.next = nullptr, don’t forget this, otherwise my linked list has a cycle in it. Complexity analysis Time complexity: O(n) Space complexity: O(n), it comes from implicit stack space due to recursion. The recursion could go up to n levels deep. Runtime: 4ms1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* p; if(head!=nullptr &amp;&amp; head-&gt;next!=nullptr)&#123; p = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; &#125; else&#123; return head; &#125; return p; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode189-Rotate Array]]></title>
    <url>%2F2018%2F09%2F01%2FArray%2F</url>
    <content type="text"><![CDATA[Multi approaches can be seen in Link Solution 1 Using Extra Array This approach using extra array sapce. I store the first k-th nums in extral array and move the rest to the right by k steps directly. Then put the extral array’s nums to the right location. When I store the first k-th nums, it prevents to lose the original elements of the array. Complexity Analysis Time complexity: O(n) Space complexity:O(k) Runtime: 24ms1234567891011121314151617181920212223242526class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); if(k==len)&#123; return; &#125; if(k&lt;len)&#123; int *a = new int[len-k]; for(int i=0;i&lt;(len-k);i++)&#123; *(a+i)=nums[i]; &#125; for(int j=(len-k);j&lt;len;j++) nums[(j+k)%len]=nums[j]; for(int p=0;p&lt;(len-k);p++) nums[p+k]=*(a+p); delete []a; &#125; if(k&gt;len)&#123; vector&lt;int&gt; a = nums; for(int i=0;i&lt;len;i++)&#123; nums[(i+k)%len] = a[i]; &#125; &#125; &#125;&#125;; Solution 2 Brute Force Submission failed with Time Limit Exceeded。 External loop k steps, and each time array is rotated by 1 unit. Complexity Analysis Time complexity: O(n * k) Space complexity: O(1) Runtime: N/A123456789101112131415class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); int cnt = 0; while(cnt&lt;k)&#123; int temp = nums[0]; for(int j=len-1;j&gt;0;j--)&#123; nums[(j+1)%len] = nums[j]; &#125; nums[1] = temp; cnt++; &#125; &#125;&#125;; Solution 3 Using Reverse reverse all elements of array reverse the first k elements reverse the rest (len-k) elements Something to notify while loop should be while(start&lt;end), not (start==end), when (start==end), it will have bugs when odd elements nums, it will skip start==end to start+1&gt;end-1. Complexity Analysis Time complexity: O(n) Space complexity:O(1) Runtime: 20ms 12345678910111213141516171819202122class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); k = k % len; reverse(nums,0,len-1); reverse(nums,0,k-1); reverse(nums,k,len-1); &#125; void reverse(vector&lt;int&gt;&amp;nums, int start, int end)&#123; while(start&lt;end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; &#125;&#125;; Solution 4 Using Cyclic Replacements This is a trick. Jump k steps in every cycle，to prevent the original elements destroying, no need to extral space. Reach back the original index, place n/k elements at correct positions Total cycles is \frac{n}{k} * k = n times，get out of external loop Complexity Analysis Time complexity: O(n) Space complexity:O(1) Runtime: 20ms 123456789101112131415161718192021222324252627282930class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); k = k % len; int start = 0; int cnt = 0; int prev; int current; int next; while(cnt&lt;nums.size())&#123; prev = nums[start]; current = (start+k)%len; next = nums[current]; cnt++; while(current!=start)&#123; nums[current] = prev; prev = next; current=(current+k)%len; next = nums[current]; cnt++; &#125; nums[current] = prev; start+=1; cout&lt;&lt;"cnt"&lt;&lt;cnt&lt;&lt;endl; &#125; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode122-Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2018%2F08%2F25%2FII%2F</url>
    <content type="text"><![CDATA[Submission 1 Simple one pass If the second num is larger than previous num, add it to profit. Traversing the array from start to end. The total sum we obtain will be the maximum profit. e.g.[1, 7, 2, 3, 6, 7, 6, 7] (3-2)+(6-3)+(7-6)=7-2=5 Complexity Analysis Time complexity: O(n) Space complexity:O(1) Runtime: 4ms1234567891011121314151617181920class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size()==0)&#123; return 0; &#125; int profit=0; int peak=0; int valley=0; for(int i=0;i&lt;prices.size()-1;i++)&#123; if(prices[i+1]&gt;prices[i])&#123; peak = prices[i+1]; valley = prices[i]; profit+=(peak-valley); &#125; &#125; return profit; &#125;&#125;; Solution 2 Peak Valley Approach To find the consecutive peak and valley value, something to notify: i is from zero, and smaller than len(array)-1. prices[i]&gt;=prices[i+1]. prices[i]&lt;=prices[i+1]. pay attention to equality sign, otherwise test case {3,3}, i will not increase, the program can not get out of outer layer of while loop. Complexity Analysis Time complexity: O(n) Space complexity:O(k) Runtime: 4ms 123456789101112131415161718192021222324class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size()==0)&#123; return 0; &#125; int profit=0; int peak=0; int valley=0; int i=0; while(i&lt;prices.size()-1)&#123; while(i&lt;prices.size()-1 &amp;&amp; prices[i]&gt;=prices[i+1])&#123; i++; &#125; valley = prices[i]; while(i&lt;prices.size()-1 &amp;&amp; prices[i]&lt;=prices[i+1])&#123; i++; &#125; peak = prices[i]; profit+=(peak-valley); &#125; return profit; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode26-Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F08%2F20%2FLeetcode26-Remove-Duplicates-from-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Solution 1 Function using Using “unique” to remove consecutive duplicates elements in array, only reserve one element. The duplicated elements are moved to the end of array, still be saved in the original array. unique function return the address of the last not duplicated element, before using unique, we should order the array. Complexity Analysis Time complexity: O(n) Space complexity:O(1) Runtime: 28ms1234567class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; nums.erase(unique(nums.begin(),nums.end()),nums.end()); return nums.size(); &#125;&#125;; Solution 2 Two Pointers First judge whether the length is 0 or later, and the speed is faster. Because in the end, as long as the length of the non-repeating element is returned, the program will automatically return the array of the first n lengths, directly count the number of non-repeating elements, and move the non-repeating elements forward, paying attention to the examination. Complexity Analysis Time complexity: O(n) Space complexity:O(1) Runtime: 24ms123456789101112131415161718class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; if (nums.size()==0) &#123; return 0; &#125; else&#123; for(int j=1;j&lt;nums.size();j++)&#123; if (nums[j]!=nums[i])&#123; nums[++i]=nums[j]; &#125; &#125; return i+1; &#125; &#125;&#125;; Solution 3 This approach is the same as Complexity Analysis Time complexity: O(n) Space complexity:O(1) Runtime: 28ms123456789101112131415161718192021class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; int j = 1; if (nums.size()&gt;0)&#123; while (j&lt;nums.size())&#123; if (nums[i] == nums[j]) j+=1; else&#123; nums[i+1] = nums[j]; i+=1; &#125; &#125; return i+1; &#125; else return 0; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
